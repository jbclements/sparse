#lang racket

;; Is wrapped around terms generated by a recursive rule.
(struct rho (e) #:transparent)
;; Is wrapped around terms generated by a variadic rule.
;; Maybe I could have just used `values` somehow?
(struct v (l) #:transparent)

(provide Rule<%> Recursive% List% Literal% Identifier% Variadic% generate-testcase rho)

;; The main function of this module. Takes in a list of Rule<%>s and
;; produces an expression that matches the grammar described by the rules
;; and is "exhaustive" in the sense that an instance of each input rule
;; will be found in each recursive spot in the grammar.
;; Note that each subterm generated by a recursive rule will be wrapped in
;; a "rho". This is so the testcase minimization knows which parts of the
;; tree it should recurse into and which it shouldn't.
;; ((Listof Rule<%>) -> rho)
(define (generate-testcase rules)
  (set-rules rules)
  (splice-v (rho (send (first rules) get-usage #t))))

;; The main interface which represents a single line in the EBNF-like grammar.
(define Rule<%>
  (interface ()
    ;; How many subterms does this rule have?
    ;; For example {rec {id = expr} expr} has a recursivity of 2.
    ;; (-> Integer)
    recursivity

    ;; Sends the list of rules down to the recursive rules, which they use
    ;; to make sure they create a usage of each different rule
    ;; ((Listof Rule) -> Void)
    set-rules

    ;; Gets a usage of the rule. This is where the magic happens. The
    ;; parameter `last?` indicates whether someone up the call tree
    ;; will call get-usage on a different term afterwards, or whether
    ;; this is the "last" call.
    ;; (Boolean -> rho)
    get-usage

    ;; Determines whether a rule has been completely "used up". The generation
    ;; should only finish when each rule returns true from this.
    ;; (-> Boolean)
    is-used?

    ;; Useful for debugging.
    ;; (-> String)
    to-string))

;; Represents a "recursive" subterm in the grammar, for example the `expr` in
;; {lam {id ...} expr}. is-used? will return false until get-usage has returned
;; a usage of each of top-level rules.
(define Recursive%
  (class* object% (Rule<%>)
    (super-new)
    ;; The top-level rules that are passed down from on high.
    (define rules #f)
    ;; The top-level rules that this Recursive term hasn't used yet.
    ;; Note that this is distinct from the concept of is-used?; a rule
    ;; can be in `unused` here even its `is-used?` returns true.
    (define unused #f)

    (define/public (recursivity) 1)

    ;; Initializes the top-level rules and marks them as unused.
    (define/public (set-rules the-rules)
      (set! rules the-rules)
      (set! unused (apply mutable-set rules)))

    ;; Returns a usage of one of the top-level rules. Which one is chosen
    ;; is determined by a fairly complicated process. Basically, if `last?`
    ;; is true, then we need to avoid returning a term with recursivity 0 unless
    ;; everyone is used up, otherwise, generation would end and we wouldn't
    ;; have used everyone. Otherwise, prioritize choosing rules that haven't
    ;; been used yet. If everyone is finished, return a rule with low recursivity
    ;; to finish things up.
    (define/public (get-usage last?)
      (define (criterion rule)
        (define the-criterion
          (list (and last? (>= (send rule recursivity) 2) (not (send rule is-used?)))
                (and last? (>= (send rule recursivity) 1) (not (send rule is-used?)))
                (set-member? unused rule)
                (not (send rule is-used?))
                (- (send rule recursivity))))
        (map bool->int the-criterion))
      (define the-rule (first (sort rules crit> #:key criterion)))
      (set-remove! unused the-rule)
      (rho (send the-rule get-usage last?)))

    ;; A recursive rule is used up if it has generated a usage of each of the
    ;; top-level rules.
    (define/public (is-used?)
      (set-empty? unused))

   (define/public (to-string)
      "PYHM")))

;; Represents a list in the grammar, for instance, {+ expr expr}, which has
;; subterms `+` (a literal), expr and expr (both recursive). 
(define List%
  (class* object% (Rule<%>)
    (init subterms)
    (define subs subterms)
    (super-new)
    (define rec (apply + (map (λ (sub) (send sub recursivity)) subs)))

    ;; The recursivity is simply the sum of the recursivities of the subterms
    (define/public (recursivity) rec)

    ;; Just passes the rules on down
    (define/public (set-rules the-rules)
      (for ([sub subs])
        (send sub set-rules the-rules)))

    ;; Returns a list of usages of each of the subterms. The order in which
    ;; we get the usages is important (due to all the mutation happening), so we
    ;; prioritize the subterms that aren't used up yet.
    (define/public (get-usage last?)
      (define usage-map (make-hash))
      (define rec-count 0)
      (define-values (do-first do-last)
        (partition (λ (i) (not (send (list-ref subs i) is-used?))) (range (length subs))))
      (for ([i (append do-first do-last)])
        (set! rec-count (+ rec-count (send (list-ref subs i) recursivity)))
        (hash-set! usage-map i (send (list-ref subs i) get-usage (and last? (= rec-count rec)))))
      (map (λ (i) (hash-ref usage-map i)) (range (length subs))))

    ;; We're used up if all our subterms are used up
    (define/public (is-used?)
      (andmap (λ (sub) (send sub is-used?)) subs))

    (define/public (to-string)
      (~a (map (λ (sub) (send sub to-string)) subs)))))

;; Represents literal terms in the grammar. Takes in a list of examples,
;; each of which will be returned in turn by get-usage.
;; For example this could represent the `if` in {if expr expr expr} (here the
;; list would be of just element: 'if).
;; Providing multiple examples is useful, for instance, for numbers, where we
;; want to use more than just one number, but don't need each individual number
;; to appear in every recursive spot.
(define Literal%
  (class* object% (Rule<%>)
    (init the-examples)
    (define examples the-examples)
    (super-new)

    ;; Literals aren't recursive
    (define/public (recursivity) 0)
    (define index 0)

    (define/public (set-rules the-rules) void)

    ;; Returns the next example, looping back to the beginning.
    (define/public (get-usage last?)
      (define usage (list-ref examples index))
      (set! index (modulo (+ index 1) (length examples)))
      usage)

    ;; Always returns true, since there is no recursivity going on here.
    ;; (Ponder: could only returning true if we've used each example at least
    ;; once guarantee that each one *will* be used at least once?)
    (define/public (is-used?) #t)

    (define/public (to-string)
      (~a (list-ref examples index)))))

;; Represents a variadic list of terms, for example, the `expr ...` in
;; {expr expr ...} or the `{id = expr} ...` in {var {id = expr} ... expr}.
;; Takes in the term to be repeated variadically.
(define Variadic%
  (class* object% (Rule<%>)
    (init repeated-term)
    (define rep repeated-term)
    (super-new)

    ;; A variadic list is as recursive as the term it repeats.
    ;; This is only *kind of* true, since any usage may have anywhere from 
    ;; 0 to 4 usages of the repeated term, but if someone is relying on us
    ;; to be recursive we'll always generate at least one.
    (define/public (recursivity) (send rep recursivity))
    (define repetitions 4)

    (define/public (set-rules the-rules)
      (send rep set-rules the-rules))

    ;; Generates up to 4 usages of the subterm. Don't generate an empty list
    ;; unless it's safe to do so (our subterm is all used up and we're not last)
    ;; Generating an empty list when we're last could potentially end the
    ;; generation while other rules are still not done yet. Note we wrap the
    ;; list of usages in `v`. This is because, syntactically, the variadic list
    ;; shouldn't really be wrapped in an actual list, but should rather be
    ;; spliced into its surroundings. The `v` signals this.
    (define/public (get-usage last?)
      (define reps (max repetitions (bool->int (or last? (not (send rep is-used?))))))
      (set! repetitions (max 0 (- repetitions 1)))
      (v (map (λ (i) (send rep get-usage (and (= i (- reps 1)) last?))) (range reps))))

    ;; Is our subterm itself used up?
    (define/public (is-used?) (send rep is-used?))

   (define/public (to-string)
      (string-append (send rep to-string) " ..."))))

;; A subclass of Literal. Takes in a list of explicit ids to use and
;; also defaults to using ids that are just letters of the alphabet.
;; Providing explicit ids is helpful to make sure students don't forbid
;; any actually valid ids.
(define Identifier%
  (class* Literal% (Rule<%>)
    (init ids)
    (define default-ids '(a b c d e f g h i j k l m n o p q r s t u v w x y z))
    (super-new [the-examples (append ids default-ids)])))

;; Passes the rules down into themselves, so the recursive terms know what the
;; rules are.
(define (set-rules rules)
  (for ([rule rules])
    (send rule set-rules rules)))

;; Splices lists wrapped in `v` into their surroundings
(define (splice-v r)
  (match r
    [(rho e) (rho (splice-v e))]
    [(? list? l) (map splice-v (append-map children l))]
    [else r]))

;; Helper for splice-v
(define (children x)
  (match x
    [(v l) l]
    [else (list x)]))

;; Take a guess what this does
(define (bool->int b)
  (match b
    [#t 1]
    [#f 0]
    [x x]))

;; Compares two lists lexicographically, comparing first the heads of the lists,
;; and then comparing the rest of the lists if the heads are equal.
(define (crit> crit1 crit2)
  (match* (crit1 crit2)
    [((cons f1 r1) (cons f2 r2))
     (if (= f1 f2)
         (crit> r1 r2)
         (> f1 f2))]
    [(_ _) #f]))
